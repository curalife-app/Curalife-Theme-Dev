name: Lighthouse PR Comment

on:
  workflow_run:
    workflows: ["Lighthouse CI"]
    types:
      - completed

jobs:
  comment:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.event == 'pull_request' }}
    steps:
      - name: Download artifacts
        uses: dawidd6/action-download-artifact@v2
        with:
          workflow: lighthouse-ci.yml
          run_id: ${{ github.event.workflow_run.id }}
          path: lighthouse-results

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Extract PR number
        id: extract-pr
        run: |
          PR_NUMBER=$(echo "${{ github.event.workflow_run.head_branch }}" | sed -n 's/^refs\/pull\/\([0-9]*\)\/merge$/\1/p')
          if [ -z "$PR_NUMBER" ]; then
            PR_NUMBER=$(echo "${{ github.event.workflow_run.head_branch }}" | grep -oP '(?<=refs/pull/)\d+(?=/merge)')
          fi
          if [ -z "$PR_NUMBER" ]; then
            # Try to get PR number from event payload
            PR_NUMBER=$(jq -r '.pull_request.number // empty' $GITHUB_EVENT_PATH 2>/dev/null || echo "")
          fi
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT

      - name: Create PR comment
        if: steps.extract-pr.outputs.pr_number != ''
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');

            // Check if we have results directories
            const resultDirs = fs.readdirSync('./lighthouse-results')
              .filter(dir => dir.endsWith('-lighthouse-results'))
              .map(dir => `./lighthouse-results/${dir}`);

            if (resultDirs.length === 0) {
              console.log('No Lighthouse result directories found');
              return;
            }

            // Process results for each page
            const pageResults = [];

            for (const dir of resultDirs) {
              const pageName = dir.split('/').pop().replace('-lighthouse-results', '');

              // Find the latest desktop report
              const desktopReports = findReports(dir, 'mobile');
              const mobileReports = findReports(`${dir}/mobile`);

              if (desktopReports.length > 0) {
                const desktopReport = JSON.parse(fs.readFileSync(desktopReports[0], 'utf8'));
                const scores = getScores(desktopReport);

                pageResults.push({
                  page: pageName,
                  device: 'desktop',
                  scores,
                  url: desktopReport.finalUrl
                });
              }

              if (mobileReports.length > 0) {
                const mobileReport = JSON.parse(fs.readFileSync(mobileReports[0], 'utf8'));
                const scores = getScores(mobileReport);

                pageResults.push({
                  page: pageName,
                  device: 'mobile',
                  scores,
                  url: mobileReport.finalUrl
                });
              }
            }

            // If we have results, create the comment
            if (pageResults.length > 0) {
              const comment = formatComment(pageResults);
              const prNumber = parseInt('${{ steps.extract-pr.outputs.pr_number }}');

              if (isNaN(prNumber)) {
                console.log('Could not determine PR number');
                return;
              }

              // Check for existing comments
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber
              });

              const botComment = comments.find(comment => {
                return comment.user.type === 'Bot' && comment.body.includes('Lighthouse Performance Report');
              });

              if (botComment) {
                // Update existing comment
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: comment
                });
              } else {
                // Create new comment
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: comment
                });
              }
            }

            // Helper functions
            function findReports(dir, excludeDir = null) {
              try {
                if (!fs.existsSync(dir)) return [];

                return fs.readdirSync(dir)
                  .filter(file => file.startsWith('lhr-') && file.endsWith('.json'))
                  .filter(file => !excludeDir || !file.includes(excludeDir))
                  .map(file => `${dir}/${file}`)
                  .sort()
                  .reverse();
              } catch (e) {
                console.error(`Error reading directory ${dir}: ${e.message}`);
                return [];
              }
            }

            function getScores(report) {
              const getScore = category => Math.round(report.categories[category].score * 100);

              return {
                performance: getScore('performance'),
                accessibility: getScore('accessibility'),
                bestPractices: getScore('best-practices'),
                seo: getScore('seo'),
                lcp: report.audits['largest-contentful-paint']?.numericValue,
                fid: report.audits['max-potential-fid']?.numericValue,
                cls: report.audits['cumulative-layout-shift']?.numericValue
              };
            }

            function getEmoji(score) {
              if (score >= 90) return 'ðŸŸ¢';
              if (score >= 75) return 'ðŸŸ ';
              return 'ðŸ”´';
            }

            function formatCoreWebVitals(scores) {
              const lcpMs = Math.round(scores.lcp);
              const fidMs = Math.round(scores.fid);
              const cls = scores.cls?.toFixed(3) || 'N/A';

              // LCP status
              let lcpStatus = '';
              if (lcpMs < 2500) lcpStatus = 'ðŸŸ¢';
              else if (lcpMs < 4000) lcpStatus = 'ðŸŸ ';
              else lcpStatus = 'ðŸ”´';

              // FID status
              let fidStatus = '';
              if (fidMs < 100) fidStatus = 'ðŸŸ¢';
              else if (fidMs < 300) fidStatus = 'ðŸŸ ';
              else fidStatus = 'ðŸ”´';

              // CLS status
              let clsStatus = '';
              if (cls < 0.1) clsStatus = 'ðŸŸ¢';
              else if (cls < 0.25) clsStatus = 'ðŸŸ ';
              else clsStatus = 'ðŸ”´';

              return `LCP: ${lcpMs}ms ${lcpStatus} | FID: ${fidMs}ms ${fidStatus} | CLS: ${cls} ${clsStatus}`;
            }

            function formatComment(results) {
              let comment = `## ðŸš¦ Lighthouse Performance Report\n\n`;

              // Group results by page
              const pageGroups = {};
              for (const result of results) {
                if (!pageGroups[result.page]) {
                  pageGroups[result.page] = [];
                }
                pageGroups[result.page].push(result);
              }

              // Create sections for each page
              for (const [page, pageResults] of Object.entries(pageGroups)) {
                comment += `### ðŸ“„ ${page.charAt(0).toUpperCase() + page.slice(1)}\n\n`;

                for (const result of pageResults) {
                  const { device, scores, url } = result;
                  const deviceIcon = device === 'desktop' ? 'ðŸ’»' : 'ðŸ“±';

                  comment += `#### ${deviceIcon} ${device.charAt(0).toUpperCase() + device.slice(1)}\n\n`;
                  comment += `| Category | Score | Core Web Vitals |\n`;
                  comment += `|---------|-------|----------------|\n`;

                  const perf = scores.performance;
                  const a11y = scores.accessibility;
                  const bp = scores.bestPractices;
                  const seo = scores.seo;

                  const perfEmoji = getEmoji(perf);
                  const a11yEmoji = getEmoji(a11y);
                  const bpEmoji = getEmoji(bp);
                  const seoEmoji = getEmoji(seo);

                  const webVitals = formatCoreWebVitals(scores);

                  comment += `| ${perfEmoji} Performance | ${perf}% | ${webVitals} |\n`;
                  comment += `| ${a11yEmoji} Accessibility | ${a11y}% | |\n`;
                  comment += `| ${bpEmoji} Best Practices | ${bp}% | |\n`;
                  comment += `| ${seoEmoji} SEO | ${seo}% | |\n\n`;

                  comment += `[View detailed report for ${url}](https://googlechrome.github.io/lighthouse/viewer/?jsonurl=${encodeURIComponent(url)})\n\n`;
                }
              }

              return comment;
            }
