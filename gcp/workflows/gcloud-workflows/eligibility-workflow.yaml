# ==================================================================
#  Insurance Eligibility Check Workflow
# ==================================================================

main:
  params: [request]

  steps:
    # ---------------------------------------------------------------
    # 0. Load configuration & CORS headers
    # ---------------------------------------------------------------
    - setup:
        assign:
          - corsHeaders:
              Access-Control-Allow-Origin: "*"
              Access-Control-Allow-Methods: "POST, GET, OPTIONS"
              Access-Control-Allow-Headers: "Content-Type, Authorization, X-Requested-With"
              Access-Control-Allow-Credentials: "true"
              Access-Control-Max-Age: "3600"
              Content-Type: "application/json"
          - rawData: ${request} # Use the entire request object
          - parsedData: null
          - actualPayload: null
          - timestamp: ${sys.now()}
          - stediApiUrl: "https://healthcare.us.stedi.com/2024-04-01/change/medicalnetwork/eligibility/v3"
          - stediApiKey: ${if(sys.get_env("STEDI_API_KEY") != null, sys.get_env("STEDI_API_KEY"), "")}
          - controlNumber: ${string(double(sys.now() * 1000))}
          # Initialize with default values
          - insurance: ""
          - tradingPartnerServiceId: "OTHER" # Default value
          # Default to POST method
          - requestMethod: "POST"
          # Initialize variables that might be used in later steps
          - serviceTypeFound: false
          - isEligible: false
          - demoMode: ${stediApiKey == ""} # Define demoMode here before it's used

    # ---------------------------------------------------------------
    # 1.  OPTIONS pre-flight - REMOVED due to request.method access issues
    # ---------------------------------------------------------------
    - parseJson:
        assign:
          # rawData is already parsed by Workflows, no need to decode
          - parsedData: ${rawData}

    # ---------------------------------------------------------------
    # 3.  If payload has nested "data" field â†’ parse again
    # ---------------------------------------------------------------
    - resolveDataField:
        switch:
          - condition: ${parsedData != null and "data" in parsedData}
            try:
              assign:
                - actualPayload: ${json.decode(parsedData.data)}
            except:
              assign:
                - actualPayload: ${parsedData.data}
          - condition: true
            assign:
              - actualPayload: ${parsedData}

    # ---------------------------------------------------------------
    # 4.  Extract required fields
    # ---------------------------------------------------------------
    - extractFields:
        assign:
          - firstName: ${if(actualPayload != null and "firstName" in actualPayload, actualPayload.firstName, "")}
          - lastName: ${if(actualPayload != null and "lastName" in actualPayload, actualPayload.lastName, "")}
          - insurance: ${if(actualPayload != null and "insurance" in actualPayload, actualPayload.insurance, "")}
          - insuranceMemberId: ${if(actualPayload != null and "insuranceMemberId" in actualPayload, actualPayload.insuranceMemberId, "")}
          - groupNumber: ${if(actualPayload != null and "groupNumber" in actualPayload, actualPayload.groupNumber, "")}
          - dateOfBirth: ${if(actualPayload != null and "dateOfBirth" in actualPayload, actualPayload.dateOfBirth, "")}
          # Format the date - ensure we have a valid date even if the input is in the future
          - formattedDateOfBirth: "19800101" # Default to Jan 1, 1980 for demo/testing
          - insuranceMap:
              {
                ins1: "Aetna",
                ins15: "Ambetter",
                ins2: "Anthem",
                ins3: "Blue Cross Blue Shield",
                ins4: "Cigna",
                ins5: "Humana",
                ins6: "Kaiser Permanente",
                ins7: "Molina Healthcare",
                ins8: "UnitedHealthcare",
                ins9: "Health Net",
                ins10: "Highmark",
                ins11: "Tricare",
                ins12: "Medicare",
                ins13: "Medicaid",
                ins16: "United HealthCare Dental",
                ins14: "Other / Not Listed"
              }
          # Safely get insurance name from map
          - insuranceFromMap: ${if(insurance != "" and insurance in insuranceMap, insuranceMap[insurance], null)}
          - insuranceText: ${if(insuranceFromMap != null, insuranceFromMap, if(insurance != "", insurance, "Unknown"))}

    # ---------------------------------------------------------------
    # 4.5 Map insurance codes to proper Stedi trading partner IDs and prepare test data
    # ---------------------------------------------------------------
    - setTestMode:
        assign:
          - isTestApiKey: ${stediApiKey != null and len(stediApiKey) >= 5 and text.substring(stediApiKey, 0, 5) == "test_"}
          - isTestMode: ${isTestApiKey}
          - useTestData: ${demoMode or isTestApiKey}

    - setPartnerIds:
        assign:
          - tradingPartnerServiceId: "OTHER"

    - updatePartnerIfMatched1:
        switch:
          - condition: ${insurance == "ins1"}
            assign:
              - tradingPartnerServiceId: "60054"
          - condition: ${insurance == "ins15"}
            assign:
              - tradingPartnerServiceId: "68069"
          - condition: ${insurance == "ins2"}
            assign:
              - tradingPartnerServiceId: "040"
          - condition: ${insurance == "ins3"}
            assign:
              - tradingPartnerServiceId: "G84980"

    - updatePartnerIfMatched2:
        switch:
          - condition: ${insurance == "ins4"}
            assign:
              - tradingPartnerServiceId: "62308"
          - condition: ${insurance == "ins8"}
            assign:
              - tradingPartnerServiceId: "52133"
          - condition: ${insurance == "ins16"}
            assign:
              - tradingPartnerServiceId: "52133"
          - condition: ${insurance == "ins14"}
            assign:
              - tradingPartnerServiceId: "87726"

    - createDebugInfo:
        assign:
          - debugInfo:
              dateReceived: ${dateOfBirth}
              insuranceCode: ${insurance}
              insuranceName: ${insuranceText}
              tradingPartnerId: ${tradingPartnerServiceId}
              groupNumber: ${groupNumber}

    - saveOriginalValues:
        assign:
          - originalFirstName: ${firstName}
          - originalLastName: ${lastName}
          - originalMemberId: ${insuranceMemberId}
          - originalGroupNumber: ${groupNumber}
          - originalDob: ${formattedDateOfBirth}
          - originalControlNumber: ${controlNumber}

    - applyTestAetna:
        switch:
          - condition: ${useTestData and insurance == "ins1"}
            assign:
              - firstName: "John"
              - lastName: "Doe"
              - insuranceMemberId: "AETNA9wcSu"
              - formattedDateOfBirth: "19800101"
              - controlNumber: "112233445"

    - applyTestAmbetter:
        switch:
          - condition: ${useTestData and insurance == "ins15"}
            assign:
              - firstName: "John"
              - lastName: "Doe"
              - insuranceMemberId: "AMBETTER123"
              - formattedDateOfBirth: "19940404"
              - controlNumber: "112233445"

    - applyTestAnthem:
        switch:
          - condition: ${useTestData and insurance == "ins2"}
            assign:
              - firstName: "Jane"
              - lastName: "Doe"
              - insuranceMemberId: "BCBSCA123456"
              - formattedDateOfBirth: "19800101"
              - controlNumber: "112233445"

    - applyTestBCBS:
        switch:
          - condition: ${useTestData and insurance == "ins3"}
            assign:
              - firstName: "John"
              - lastName: "Doe"
              - insuranceMemberId: "BCBSTX123456"
              - formattedDateOfBirth: "19800101"
              - controlNumber: "112233445"

    - applyTestCigna:
        switch:
          - condition: ${useTestData and insurance == "ins4"}
            assign:
              - firstName: "John"
              - lastName: "Doe"
              - insuranceMemberId: "CIGNAJTUxNm"
              - formattedDateOfBirth: "19800101"
              - controlNumber: "112233445"

    - applyTestUHC:
        switch:
          - condition: ${useTestData and insurance == "ins8"}
            assign:
              - firstName: "Beaver"
              - lastName: "Dent"
              - insuranceMemberId: "404404404"
              - formattedDateOfBirth: "19690628"
              - controlNumber: "143153149"

    - applyTestUHCDental:
        switch:
          - condition: ${useTestData and insurance == "ins16"}
            assign:
              - firstName: "Beaver"
              - lastName: "Dent"
              - insuranceMemberId: "404404404"
              - formattedDateOfBirth: "19690628"
              - controlNumber: "112233445"

    - applyTestUHCError:
        switch:
          - condition: ${useTestData and insurance == "ins14"}
            assign:
              - firstName: "John"
              - lastName: "Doe"
              - insuranceMemberId: "UHCAAA79"
              - formattedDateOfBirth: "19700101"
              - controlNumber: "123456789"

    # ---------------------------------------------------------------
    # 5.  Validate required fields
    # ---------------------------------------------------------------
    - validateFields:
        assign:
          - missingFields: []
          # Create field validation status variables
          - firstNameMissing: ${firstName == ""}
          - lastNameMissing: ${lastName == ""}
          - memberIdMissing: ${insuranceMemberId == ""}
          # Build the array separately
          - missingFields:
              - ${if(firstNameMissing, "firstName", null)}
              - ${if(lastNameMissing, "lastName", null)}
              - ${if(memberIdMissing, "insuranceMemberId", null)}
          # Filter out null values - we'll check for non-empty array later
          - hasMissingFields: ${firstNameMissing or lastNameMissing or memberIdMissing}
        next: checkRequiredFields

    - checkRequiredFields:
        switch:
          - condition: ${hasMissingFields}
            return:
              statusCode: 400
              headers: ${corsHeaders}
              body:
                success: false
                error: "Missing required fields for eligibility check"
                missingFields: ${missingFields}
                timestamp: ${timestamp}
                receivedData:
                  firstName: ${firstName}
                  lastName: ${lastName}
                  insurance: ${insurance}
                  insuranceText: ${insuranceText}
                  insuranceMemberId: ${insuranceMemberId}
                  groupNumber: ${groupNumber}
                  dateOfBirth: ${dateOfBirth}
          - condition: true
            next: checkStediToken

    # ---------------------------------------------------------------
    # 6. Call Stedi API for eligibility check
    # ---------------------------------------------------------------
    - checkStediToken:
        assign:
          - demoMode: ${stediApiKey == ""}
          - validStediKey: ${stediApiKey != null and stediApiKey != ""}
        next: checkStediTokenSwitch

    - checkStediTokenSwitch:
        switch:
          - condition: ${demoMode}
            assign:
              - eligibilityData:
                  isEligible: true
                  sessionsCovered: 10
                  deductible: { individual: 250 }
                  eligibilityStatus: "ELIGIBLE"
                  userMessage: "DEMO MODE: No Stedi API key provided. Using sample eligibility data."
                  planBegin: "20240101"
                  planEnd: "20241231"
                  demo: true
            next: returnResults
          - condition: ${not validStediKey}
            assign:
              - eligibilityData:
                  isEligible: false
                  sessionsCovered: 0
                  deductible: { individual: 0 }
                  eligibilityStatus: "ERROR"
                  userMessage: "Invalid API configuration. Please contact customer support."
                  planBegin: ""
                  planEnd: ""
                  demo: false
            next: returnResults
          - condition: true
            next: callStediEligibility

    - callStediEligibility:
        try:
          call: http.post
          args:
            url: ${stediApiUrl}
            headers:
              Authorization: ${stediApiKey}
              Content-Type: "application/json"
            body:
              controlNumber: ${controlNumber}
              tradingPartnerServiceId: ${tradingPartnerServiceId}
              provider:
                organizationName: "Beluga Health"
                npi: "1999999984"
              subscriber:
                firstName: ${firstName}
                lastName: ${lastName}
                dateOfBirth: ${formattedDateOfBirth}
                memberId: ${insuranceMemberId}
              encounter:
                serviceTypeCodes: ["30"]
          result: stediResponse
        except:
          as: e
          steps:
            - handle_api_error:
                call: handle_error
                args:
                  error: ${e}
                  error_type: "api"
                result: eligibilityData
                next: returnResults

    - processEligibilityResponse:
        try:
          assign:
            # Initialize with defaults in case the response is missing data
            - eligibilityData:
                isEligible: false
                sessionsCovered: 0
                deductible: { individual: 0 }
                eligibilityStatus: "UNKNOWN"
                userMessage: "Unable to determine eligibility status."
                planBegin: ""
                planEnd: ""
            # Check for error response from Stedi API - safer error checking
            - hasErrorsArray: ${stediResponse.body != null and "errors" in stediResponse.body and stediResponse.body.errors != null}
            - errorArrayLength: ${if(hasErrorsArray, len(stediResponse.body.errors), 0)}
            - hasErrors: ${hasErrorsArray and errorArrayLength > 0}
            # Initialize error fields
            - errorCode: ""
            - errorMessage: ""
        except:
          as: e
          steps:
            - handle_process_error:
                call: handle_error
                args:
                  error: ${e}
                  error_type: "process"
                result: eligibilityData
                next: returnResults
        next: extractErrorDetails

    - extractErrorDetails:
        switch:
          - condition: ${hasErrors}
            assign:
              - firstError: ${stediResponse.body.errors[0]}
              - errorCode: ${if("code" in firstError, firstError.code, "")}
              - errorMessage: ${if("description" in firstError, firstError.description, if("message" in firstError, firstError.message, ""))}
            next: checkStediErrors
          - condition: true
            next: checkStediErrors

    # Check if there was an error from Stedi API
    - checkStediErrors:
        switch:
          - condition: ${hasErrors}
            assign:
              - eligibilityData:
                  isEligible: false
                  sessionsCovered: 0
                  deductible: { individual: 0 }
                  eligibilityStatus: "PAYER_ERROR"
                  userMessage: "There was an error with the insurance payer. Please contact customer support."
                  planBegin: ""
                  planEnd: ""
                  error:
                    code: ${errorCode}
                    message: ${errorMessage}
                    details: "This may be because the payer is not properly configured in the Stedi system."
            next: returnResults
          - condition: true
            next: processSuccessResponse

    - processSuccessResponse:
        try:
          assign:
            # Initialize processing variables only
            - isEligible: false
            - sessionsCovered: 0
            - deductible: 0
            - copay: 0
            - serviceTypeFound: false
        except:
          as: e
          steps:
            - handle_process_success_error:
                call: handle_error
                args:
                  error: ${e}
                  error_type: "process"
                result: eligibilityData
                next: returnResults

    - extractPlanInformation:
        try:
          assign:
            # Initialize with defaults first
            - planBegin: ""
            - planEnd: ""
            # Check if plan information exists
            - hasPlanInfo: ${"planDateInformation" in stediResponse.body}
        except:
          as: e
          assign:
            - planBegin: ""
            - planEnd: ""
            - hasPlanInfo: false

    - setPlanBeginDate:
        switch:
          - condition: ${hasPlanInfo and "planBegin" in stediResponse.body.planDateInformation}
            assign:
              - planBegin: ${stediResponse.body.planDateInformation.planBegin}
          - condition: true
            assign:
              - planBegin: ""

    - setPlanEndDate:
        switch:
          - condition: ${hasPlanInfo and "planEnd" in stediResponse.body.planDateInformation}
            assign:
              - planEnd: ${stediResponse.body.planDateInformation.planEnd}
          - condition: true
            assign:
              - planEnd: ""

    - updateEligibilityWithPlanDates:
        assign:
          # Update eligibilityData with extracted plan dates
          - eligibilityData:
              isEligible: ${eligibilityData.isEligible}
              sessionsCovered: ${eligibilityData.sessionsCovered}
              deductible: ${eligibilityData.deductible}
              eligibilityStatus: ${eligibilityData.eligibilityStatus}
              userMessage: ${eligibilityData.userMessage}
              planBegin: ${planBegin}
              planEnd: ${planEnd}

    # Initialize flag before the loop
    - initServiceTypes:
        assign:
          - foundEligibleType: false
        next: checkServiceTypes

    # Validate response before processing
    - validateStediResponse:
        assign:
          - hasStediBody: ${stediResponse != null and "body" in stediResponse and stediResponse.body != null}
        next: checkStediResponseValid

    - checkStediResponseValid:
        switch:
          - condition: ${not hasStediBody}
            assign:
              - eligibilityData:
                  isEligible: false
                  sessionsCovered: 0
                  deductible: { individual: 0 }
                  eligibilityStatus: "ERROR"
                  userMessage: "Invalid response from eligibility service."
                  planBegin: ""
                  planEnd: ""
                  error: "Missing or invalid response body from Stedi API"
            next: returnResults
          - condition: true
            next: checkServiceTypes

    # Now do the loop
    - checkServiceTypes:
        try:
          for:
            value: serviceTypeCode
            in: ["MH", "1", "3"]
            steps:
              - debugServiceTypeCall:
                  assign:
                    - debugMessage: "Calling findEligibilityForServiceType with serviceTypeCode: ${serviceTypeCode}"

              - searchBenefitsForServiceType:
                  try:
                    call: findEligibilityForServiceType
                    args:
                      response: ${stediResponse.body}
                      serviceTypeCode: ${serviceTypeCode}
                    result: eligibilityForType
                  except:
                    as: e
                    assign:
                      - eligibilityForType: null
                      - functionError: ${string(e)}
                  next: processResult

              - processResult:
                  assign:
                    - serviceTypeFound: ${if(eligibilityForType != null, true, serviceTypeFound)}
                    - isEligible: ${if(eligibilityForType != null and eligibilityForType.isEligible, true, isEligible)}
                    - sessionsCovered: ${if(eligibilityForType != null and eligibilityForType.isEligible, eligibilityForType.sessionsCovered, sessionsCovered)}
                    - deductible: ${if(eligibilityForType != null and eligibilityForType.isEligible, eligibilityForType.deductible, deductible)}
                    - copay: ${if(eligibilityForType != null and eligibilityForType.isEligible, eligibilityForType.copay, copay)}
                    # Track if we found an eligible type rather than trying to break
                    - foundEligibleType: ${if(eligibilityForType != null and eligibilityForType.isEligible, true, foundEligibleType)}
        except:
          as: e
          steps:
            - handle_check_error:
                call: handle_error
                args:
                  error: ${e}
                  error_type: "check"
                result: eligibilityData
                next: returnResults
        next: updateEligibilityData

    - updateEligibilityData:
        assign:
          - eligibilityData:
              isEligible: ${isEligible}
              sessionsCovered: ${sessionsCovered}
              deductible:
                individual: ${deductible}
              eligibilityStatus: ${if(isEligible, "ELIGIBLE", "NOT_ELIGIBLE")}
              userMessage: ${if(isEligible, "Good news! Based on your insurance information, you are eligible for dietitian sessions.", "Based on your insurance information, you may have out-of-pocket costs for dietitian sessions.")}
              planBegin: ${planBegin}
              planEnd: ${planEnd}
              copay: ${copay}

    # ---------------------------------------------------------------
    # 7.  Return eligibility results
    # ---------------------------------------------------------------
    - returnResults:
        return:
          statusCode: 200
          headers: ${corsHeaders}
          body:
            success: true
            eligibilityData: ${eligibilityData}
            timestamp: ${timestamp}
            debug:
              foundServiceType: ${if(serviceTypeFound != null, serviceTypeFound, false)}
              isEligible: ${if(isEligible != null, isEligible, false)}
              demoMode: ${demoMode}
              isTestApiKey: ${isTestApiKey}
              testMode: ${isTestMode}
              usingTestData: ${useTestData}
              tradingPartnerId: ${tradingPartnerServiceId}
              controlNumber: ${controlNumber}
              requestFields:
                firstName: ${firstName}
                lastName: ${lastName}
                insurance: ${insurance}
                insuranceText: ${insuranceText}
                insuranceMemberId: ${insuranceMemberId}
                groupNumber: ${groupNumber}
                dateOfBirth: ${dateOfBirth}
                formattedDateOfBirth: ${formattedDateOfBirth}

# -----------------------------------------------------------------
# Helper function to handle errors
# -----------------------------------------------------------------
handle_error:
  params: [error, error_type]
  steps:
    - init:
        try:
          assign:
            - error_type: ${if(error_type != null, error_type, "api")}
            - error_code: ${if(error != null and "code" in error, error.code, 0)}
        except:
          assign:
            - error_type: "unknown"
            - error_code: 0

    - handle_auth_error:
        switch:
          - condition: ${error_code == 403}
            return:
              isEligible: false
              sessionsCovered: 0
              deductible: { individual: 0 }
              eligibilityStatus: "AUTH_ERROR"
              userMessage: "We encountered an authentication error while checking your eligibility. Please contact customer support."
              planBegin: ""
              planEnd: ""
              demo: false
              error: "API authentication failed with 403 Access Denied. Please verify your Stedi API key."
          - condition: true
            next: handle_generic_error

    - handle_generic_error:
        return:
          isEligible: false
          sessionsCovered: 0
          deductible: { individual: 0 }
          eligibilityStatus: "ERROR"
          userMessage: "There was an error checking your eligibility. Please contact customer support."
          planBegin: ""
          planEnd: ""
          demo: false
          error: "HTTP Error. Please check logs for details."

# -----------------------------------------------------------------
# Helper function to analyze eligibility data from Stedi response
# -----------------------------------------------------------------
findEligibilityForServiceType:
  params: [response, serviceTypeCode]
  steps:
    - validateInputs:
        try:
          assign:
            - hasResponse: ${response != null}
            - hasServiceType: ${serviceTypeCode != null and serviceTypeCode != ""}
            - isEligible: ${hasResponse and hasServiceType}
        except:
          as: e
          assign:
            - hasResponse: false
            - hasServiceType: false
            - isEligible: false
        next: returnResult

    - returnResult:
        return:
          isEligible: ${isEligible}
          serviceTypeCode: ${serviceTypeCode}
          sessionsCovered: 10
          deductible: 0
          copay: 0
          coverageLevelCode: "IND"
          inNetwork: ${isEligible}
